[
  {
    "coverImage": "/media/blog/expo.png",
    "slug": "expo-react-native-setup",
    "title": "Kickstarting Your Mobile App with Expo & React Native",
    "excerpt": "A practical guide to setting up your first mobile app using Expo and React Native.",
    "date": "2025-05-06",
    "content": "Expo is the fastest way to start building React Native apps without installing Xcode or Android Studio. It's perfect for rapid prototyping, testing, and even launching full-scale production apps.\n\n## Why Expo?\n- **Instant setup**: No native build tools required\n- **Cross-platform**: iOS, Android, and Web support out of the box\n- **Built-in APIs**: Camera, push notifications, geolocation, and more\n\n## Prerequisites\nBefore starting, make sure you have Node.js installed.\n\n## Setting Up\nInstall Expo CLI globally:\n```bash\nnpm install -g expo-cli\n```\n\nCreate a new project:\n```bash\nexpo init my-app\n```\nChoose from blank, tabs (with navigation), or other templates.\n\nRun the app locally:\n```bash\ncd my-app\nnpm start\n```\nUse the QR code in Expo Go (iOS/Android) to test instantly.\n\n## Folder Structure\nA clean folder layout helps scalability:\n```\nmy-app/\n├── App.js\n├── assets/\n├── components/\n├── screens/\n└── navigation/\n```\n\n## Using Components\nCreate reusable UI:\n```jsx\nexport default function Button({ label, onPress }) {\n  return <Pressable onPress={onPress}><Text>{label}</Text></Pressable>;\n}\n```\n\n## Deployment\nUse EAS (Expo Application Services):\n```bash\neas build --platform all\n```\nSubmit using EAS Submit:\n```bash\neas submit --platform ios\n```\n\n## Wrap-Up\nExpo accelerates mobile development by handling complexity under the hood. Focus on UX and features while Expo manages builds, testing, and deployment."
  },
  {
    "coverImage": "/media/blog/kotlin.avif",
    "slug": "kotlin-android-modern-ui",
    "title": "Building Modern Android UIs with Kotlin",
    "excerpt": "Take your Android UI skills to the next level using modern Kotlin patterns and Jetpack Compose.",
    "date": "2025-05-06",
    "content": "Kotlin + Jetpack Compose is the new standard for modern Android UI development. With Compose, XML layouts are gone—you write UIs entirely in Kotlin.\n\n## Jetpack Compose Basics\nCompose uses `@Composable` functions to define UI elements:\n```kotlin\n@Composable\nfun Greeting(name: String) {\n    Text(text = \"Hello $name\")\n}\n```\n\n## Managing State\nCompose encourages reactive programming:\n```kotlin\nvar count by remember { mutableStateOf(0) }\nButton(onClick = { count++ }) {\n    Text(\"Clicked $count times\")\n}\n```\n\n## UI Layouts\nCompose uses `Row`, `Column`, `Box`, and other layout primitives.\n```kotlin\nColumn(modifier = Modifier.padding(16.dp)) {\n    Text(\"Welcome\")\n    Button(onClick = { /* ... */ }) {\n        Text(\"Continue\")\n    }\n}\n```\n\n## Theming\nThemes are managed via `MaterialTheme`:\n```kotlin\nMaterialTheme(\n    colors = lightColors(primary = Color.Blue),\n    typography = Typography(),\n    shapes = Shapes()\n) {\n    // Content here\n}\n```\n\n## Navigation\nCompose Navigation simplifies routing:\n```kotlin\nNavHost(navController, startDestination = \"home\") {\n    composable(\"home\") { HomeScreen() }\n    composable(\"details/{id}\") { backStack ->\n        val id = backStack.arguments?.getString(\"id\")\n        DetailsScreen(id)\n    }\n}\n```\n\n## Conclusion\nKotlin and Compose offer a cleaner, more powerful way to build Android UIs. Learn the core building blocks, and you'll be writing fluid, maintainable UIs in no time."
  },
  {
    "coverImage": "/media/blog/swiftui.png",
    "slug": "swiftui-layout-basics",
    "title": "Getting Started with Layout in SwiftUI",
    "excerpt": "Discover how to build beautiful layouts using SwiftUI’s powerful and declarative approach.",
    "date": "2025-05-05",
    "content": "SwiftUI is Apple’s declarative UI framework designed to unify UI development across iOS, macOS, watchOS, and tvOS. Layouts are handled using a combination of stacks and modifiers.\n\n## Stack Basics\n- `VStack`: Vertical layout\n- `HStack`: Horizontal layout\n- `ZStack`: Overlapping layers\n\nExample:\n```swift\nVStack(alignment: .leading) {\n    Text(\"Welcome\")\n    Text(\"To SwiftUI\")\n}\n```\n\n## Modifiers\nModifiers change how views are displayed:\n```swift\nText(\"Styled Text\")\n    .font(.headline)\n    .padding()\n    .background(Color.yellow)\n    .cornerRadius(10)\n```\n\n## Responsive Layouts\nUse `GeometryReader` to access size data:\n```swift\nGeometryReader { geometry in\n    Text(\"Width: \\(geometry.size.width)\")\n}\n```\n\n## Building Reusable Views\n```swift\nstruct CustomCard: View {\n    var title: String\n\n    var body: some View {\n        VStack {\n            Text(title)\n                .font(.title)\n                .padding()\n        }\n        .background(Color.gray.opacity(0.2))\n        .cornerRadius(8)\n    }\n}\n```\n\n## Wrap-Up\nSwiftUI makes UI development elegant and concise. Learn to compose views with stacks and leverage modifiers to build beautiful, responsive interfaces across Apple platforms."
  },
  {
    "coverImage": "/media/blog/react.png",
    "slug": "accessible-react-components",
    "title": "Building Accessible React Components That Everyone Can Use",
    "excerpt": "Learn how to make React components accessible without compromising design or usability.",
    "date": "2025-05-03",
    "content": "Building accessible React components ensures your app works for everyone, including those with disabilities.\n\n## Semantic HTML First\nUse real HTML elements:\n- `<button>` over `<div>` for clicks\n- `<label>` + `<input>` for form controls\n\nExample:\n```jsx\n<label htmlFor=\"email\">Email</label>\n<input type=\"email\" id=\"email\" />\n```\n\n## Keyboard Navigation\nSupport `Tab`, `Enter`, and `Escape`:\n```jsx\nconst handleKeyDown = (e) => {\n  if (e.key === 'Enter') openModal();\n};\n```\n\n## Aria Roles and Properties\n- `aria-label`\n- `aria-expanded`\n- `aria-live`\n\nUse them where semantics alone don't cover it:\n```jsx\n<button aria-label=\"Close modal\">×</button>\n```\n\n## Focus Management\nTrap focus inside modals:\n```jsx\nuseEffect(() => {\n  modalRef.current.focus();\n}, []);\n```\n\n## Color Contrast and Design\n- Ensure 4.5:1 contrast ratio\n- Avoid relying on color alone to convey meaning\n\n## Testing Tools\n- **Axe DevTools**: Chrome extension\n- **Lighthouse**: In Chrome DevTools\n- **VoiceOver/NVDA**: Screen reader testing\n\n## Wrap-Up\nDon’t bolt accessibility on at the end. Build it in from day one. Small tweaks can make huge differences in usability and inclusivity."
  },
  {
    "coverImage": "/media/blog/nextjs.webp",
    "slug": "nextjs-app-router-best-practices",
    "title": "Mastering Next.js App Router: Best Practices for Modern Web Apps",
    "excerpt": "Explore essential patterns and practical tips for working with the Next.js App Router effectively.",
    "date": "2025-07-01",
    "content": "Next.js 13 and above introduces a new App Router system with support for layouts, nested routing, and server components.\n\n## File-Based Routing\nCreate routes by structuring folders in the `app` directory:\n```txt\napp/\n  page.js\n  about/\n    page.js\n  blog/\n    [slug]/\n      page.js\n```\n\n## Layouts\nPersistent UI elements like navbars or sidebars belong in `layout.js`.\n```jsx\nexport default function RootLayout({ children }) {\n  return (\n    <html lang=\"en\">\n      <body>\n        <Navbar />\n        {children}\n        <Footer />\n      </body>\n    </html>\n  );\n}\n```\n\n## Loading UI\nUse `loading.js` in each route folder to show skeleton UIs while the page loads.\n\n## Error Handling\nUse `error.js` to gracefully catch rendering issues in route segments.\n\n## Metadata API\nNext.js handles SEO with built-in metadata configuration:\n```js\nexport const metadata = {\n  title: 'Home | MySite',\n  description: 'Welcome to my site',\n};\n```\n\n## Server & Client Components\nEverything is server-rendered by default. Add `'use client'` to enable interactivity:\n```jsx\n'use client';\nexport default function ToggleButton() {\n  const [on, setOn] = useState(false);\n  return <button onClick={() => setOn(!on)}>{on ? 'On' : 'Off'}</button>;\n}\n```\n\n## Wrap-Up\nThe App Router introduces a clean architecture for scalable apps. Embrace server components for performance and use layouts, loading, and error files to enhance UX."
  }
]
